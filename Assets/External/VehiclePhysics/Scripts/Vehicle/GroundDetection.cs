using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using NWH.WheelController3D;

namespace NWH.VehiclePhysics
{
    public class GroundDetection : MonoBehaviour
    {
        /// <summary>
        /// Prefab of the particle system for generating smoke as a result of spinning or slipping tires.
        /// </summary>
        [Tooltip("Prefab of the particle system for generating smoke as a result of spinning or slipping tires.")]
        public GameObject smokePrefab;

        /// <summary>
        /// Prefab of the particle system for generating dust as a result of traveling over sand, gravel, etc.
        /// </summary>
        [Tooltip("Prefab of the particle system for generating dust as a result of traveling over sand, gravel, etc.")]
        public GameObject dustPrefab;

        /// <summary>
        /// A class representing a single ground surface type.
        /// </summary>
        [System.Serializable]
        public class GroundEntity
        {
            /// <summary>
            /// Name of the ground entity.
            /// </summary>
            [Tooltip("Name of the ground entity.")]
            public string name;

            /// <summary>
            /// Indices of terrain textures that represent this type of surface. Starts with 0 with the first texture being in the top left corner
            /// under terrain settings - Paint Texture.
            /// </summary>
            [Tooltip("Indices of terrain textures that represent this type of surface. Starts with 0 with the first texture being in the top left corner " +
                "under terrain settings - Paint Texture.")]
            public List<int> terrainTextureIndices = new List<int>();

            /// <summary>
            /// Objects with tags in this list will be recognized as this type of surface.
            /// </summary>
            [Tooltip("Objects with tags in this list will be recognized as this type of surface.")]
            public List<string> tags = new List<string>();

            /// <summary>
            /// Friction preset of WC3D that will be used for this surface. More presets can be added in WheelController.FrictionPresets.
            /// </summary>
            [Tooltip("Friction preset of WC3D that will be used for this surface. More presets can be added in WheelController.FrictionPresets.")]
            public WheelController.FrictionPreset.FrictionPresetEnum frictionPresetEnum;

          
            // Skidmarks
            [Header("Skidmarks")]

            /// <summary>
            /// Material that will be used when generating skidmarks.
            /// </summary>
            [Tooltip("Material that will be used when generating skidmarks.")]
            public Material skidmarkMaterial;

            /// <summary>
            /// If set to true sidmarks will be dependent on wheel's slip (true for asphalt, concrete, etc.).
            /// </summary>
            [Tooltip("If set to true sidmarks will be dependent on wheel's slip (true for asphalt, concrete, etc.).")]
            public bool slipBasedSkidIntensity = false;

            // Particle Effects
            [Header("Particle Effects")]

            /// <summary>
            /// Intensity of smoke generated by wheel slip.
            /// </summary>
            [Tooltip("Intensity of smoke generated by wheel slip.")]
            [Range(0,50)]
            public float smokeIntensity = 30f;

            /// <summary>
            /// Intensity of dust generated by wheel traveling over sand, gravel, etc.
            /// </summary>
            [Tooltip("Intensity of dust generated by wheel traveling over sand, gravel, etc.")]
            [Range(0,50)]
            public float dustIntensity = 0f;

            /// <summary>
            /// Color of dust generated by wheel traveling over sand, gravel, etc.
            /// </summary>
            [Tooltip("Color of dust generated by wheel traveling over sand, gravel, etc.")]
            public Color dustColor = Color.yellow;

            // Sounds
            [Header("Sound")]

            /// <summary>
            /// If set to true surface volume will be dependent on slip (asphalt, concrete, etc.).
            /// Set to false for dirt, grass and other soft surfaces.
            /// </summary>
            [Tooltip("If set to true surface volume will be dependent on slip (asphalt, concrete, etc.)." +
                " Set to false for dirt, grass and other soft surfaces.")]
            public bool slipSensitiveSurfaceSound;

            /// <summary>
            /// Sound generated by tire rolling over surface.
            /// </summary>
            [Tooltip("Sound generated by tire rolling over surface.")]
            public SoundComponent surfaceSoundComponent;

            /// <summary>
            /// Sound produced by tire skidding over surface.
            /// </summary>
            [Tooltip("Sound produced by tire skidding over surface.")]
            public SoundComponent skidSoundComponent;
        }

        /// <summary>
        /// Ground entities - each represents a single ground surface.
        /// </summary>
        [Tooltip("Ground entities - each represents a single ground surface.")]
        [SerializeField]
        public List<GroundEntity> groundEntities = new List<GroundEntity>();

        private Terrain activeTerrain;
        private TerrainData terrainData;
        private Vector3 terrainPos;
        private float[] mix;
        private float[,,] splatmapData;

        /// <summary>
        /// Base class for surface sounds.
        /// </summary>
        [System.Serializable]
        public class SoundComponent
        {
            [Range(0f, 2f)]
            public float volume = 0.6f;

            [Range(0f, 2f)]
            public float pitch = 1f;

            public AudioClip clip;
            [HideInInspector]
            public AudioSource source;
        }

        /// <summary>
        /// Gets index of current ground entity in ground entities list.
        /// </summary>
        public int GetCurrentGroundEntityIndex(WheelController wheelController)
        {
            GroundEntity groundEntity = GetCurrentGroundEntity(wheelController);
            if(groundEntity != null)
            {
                return groundEntities.IndexOf(groundEntity);
            }
            else
            {
                return -1;
            }
        }

        /// <summary>
        /// Returns skidmark material for the current texture.
        /// </summary>
        public Material GetCurrentSkidmarkTexture(WheelController wheelController)
        {
            GroundEntity groundEntity = GetCurrentGroundEntity(wheelController);
            if (groundEntity != null)
            {
                return GetCurrentGroundEntity(wheelController).skidmarkMaterial;
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Gets the ground entity the wheel is currently on.
        /// </summary>
        public GroundEntity GetCurrentGroundEntity(WheelController wheelController)
        {
            if (wheelController.isGrounded && wheelController.wheelHit != null && wheelController.wheelHit.raycastHit.transform != null)
            {
                WheelController.WheelHit hit = null;
                wheelController.GetGroundHit(out hit);

                // Check for tags
                foreach (GroundEntity groundEntity in groundEntities)
                {
                    if (groundEntity.tags.Count > 0 
                        && groundEntity.tags.Contains(wheelController.wheelHit.raycastHit.transform.tag))
                    {
                        return groundEntity;
                    }
                }

                // Find active terrain
                activeTerrain = hit.raycastHit.transform?.GetComponent<Terrain>();

                if(activeTerrain)
                {
                    // Check for terrain textures
                    int dominantTerrainIndex = GetDominantTerrainTexture(hit.point, activeTerrain);
                    if (dominantTerrainIndex != -1)
                    {
                        foreach (GroundEntity groundEntity in groundEntities)
                        {
                            if (groundEntity.terrainTextureIndices.Count > 0 && groundEntity.terrainTextureIndices.Contains(dominantTerrainIndex))
                            {
                                return groundEntity;
                            }
                        }
                    }
                }
            }

            return null;
        }

        private void GetTerrainTextureComposition(Vector3 worldPos, Terrain terrain, ref float[] cellMix)
        {
            try
            {
                terrainData = terrain.terrainData;
                terrainPos = terrain.transform.position;
                // Calculate which splat map cell the worldPos falls within (ignoring y)
                int mapX = (int)(((worldPos.x - terrainPos.x) / terrainData.size.x) * terrainData.alphamapWidth);
                int mapZ = (int)(((worldPos.z - terrainPos.z) / terrainData.size.z) * terrainData.alphamapHeight);
                // Get the splat data for this cell as a 1x1xN 3d array (where N = number of textures)
                splatmapData = terrainData.GetAlphamaps(mapX, mapZ, 1, 1);
                // Extract the 3D array data to a 1D array:
                cellMix = new float[splatmapData.GetUpperBound(2) + 1];
                for (int n = 0; n < cellMix.Length; ++n)
                {
                    cellMix[n] = splatmapData[0, 0, n];
                }
            }
            catch
            {
                cellMix = null;
            }
        }

        /// <summary>
        /// Returns most prominent texture at the point in a terrain.
        /// </summary>
        private int GetDominantTerrainTexture(Vector3 worldPos, Terrain terrain)
        {
            // returns the zero-based index of the most dominant texture
            // on the main terrain at this world position.
            GetTerrainTextureComposition(worldPos, terrain, ref mix);
            if(mix != null)
            {
                float maxMix = 0;
                int maxIndex = 0;
                // loop through each mix value and find the maximum
                for (int n = 0; n < mix.Length; ++n)
                {
                    if (mix[n] > maxMix)
                    {
                        maxIndex = n;
                        maxMix = mix[n];
                    }
                }
                return maxIndex;
            }
            else
            {
                return -1;
            }
        }
    }
}

